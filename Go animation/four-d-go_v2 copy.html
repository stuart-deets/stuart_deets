<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Go Tesseract</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: transparent;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
        }
        
        .container {
            height: 500vh; /* Long scroll for extended animation */
        }
        
        .fixed-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas class="fixed-canvas" id="canvas"></canvas>
    </div>

    <script>
        class Vector4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            
            clone() {
                return new Vector4(this.x, this.y, this.z, this.w);
            }
        }

        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        class Matrix4D {
            constructor() {
                this.elements = new Array(16).fill(0);
                this.identity();
            }
            
            identity() {
                for (let i = 0; i < 16; i++) {
                    this.elements[i] = (i % 5 === 0) ? 1 : 0;
                }
                return this;
            }
            
            rotateXY(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[0] = c; m.elements[1] = -s;
                m.elements[4] = s; m.elements[5] = c;
                m.elements[10] = 1;
                m.elements[15] = 1;
                return this.multiply(m);
            }
            
            rotateXZ(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[0] = c; m.elements[2] = -s;
                m.elements[8] = s; m.elements[10] = c;
                m.elements[5] = 1;
                m.elements[15] = 1;
                return this.multiply(m);
            }
            
            rotateXW(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[0] = c; m.elements[3] = -s;
                m.elements[12] = s; m.elements[15] = c;
                m.elements[5] = 1;
                m.elements[10] = 1;
                return this.multiply(m);
            }
            
            rotateYZ(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[5] = c; m.elements[6] = -s;
                m.elements[9] = s; m.elements[10] = c;
                m.elements[0] = 1;
                m.elements[15] = 1;
                return this.multiply(m);
            }
            
            rotateYW(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[5] = c; m.elements[7] = -s;
                m.elements[13] = s; m.elements[15] = c;
                m.elements[0] = 1;
                m.elements[10] = 1;
                return this.multiply(m);
            }
            
            rotateZW(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const m = new Matrix4D();
                m.elements[10] = c; m.elements[11] = -s;
                m.elements[14] = s; m.elements[15] = c;
                m.elements[0] = 1;
                m.elements[5] = 1;
                return this.multiply(m);
            }
            
            multiply(m) {
                const result = new Matrix4D();
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            sum += this.elements[i * 4 + k] * m.elements[k * 4 + j];
                        }
                        result.elements[i * 4 + j] = sum;
                    }
                }
                return result;
            }
            
            transform(v) {
                const x = v.x * this.elements[0] + v.y * this.elements[1] + v.z * this.elements[2] + v.w * this.elements[3];
                const y = v.x * this.elements[4] + v.y * this.elements[5] + v.z * this.elements[6] + v.w * this.elements[7];
                const z = v.x * this.elements[8] + v.y * this.elements[9] + v.z * this.elements[10] + v.w * this.elements[11];
                const w = v.x * this.elements[12] + v.y * this.elements[13] + v.z * this.elements[14] + v.w * this.elements[15];
                return new Vector4(x, y, z, w);
            }
        }

        class FourDGo {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Animation state
                this.time = 0;
                this.lastScrollPosition = 0;
                this.scrollVelocity = 0;
                this.ambientRotation = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
                
                this.setupCanvas();
                this.createTesseract();
                this.createStones();
                this.setupEventListeners();
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.scale = Math.min(this.canvas.width, this.canvas.height) / 8;
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.scale = Math.min(this.canvas.width, this.canvas.height) / 8;
            }
            
            createTesseract() {
                // Create tesseract vertices in 4D
                this.vertices4D = [];
                for (let x = -1; x <= 1; x += 2) {
                    for (let y = -1; y <= 1; y += 2) {
                        for (let z = -1; z <= 1; z += 2) {
                            for (let w = -1; w <= 1; w += 2) {
                                this.vertices4D.push(new Vector4(x, y, z, w));
                            }
                        }
                    }
                }
                
                // Create edges
                this.edges = [];
                for (let i = 0; i < this.vertices4D.length; i++) {
                    for (let j = i + 1; j < this.vertices4D.length; j++) {
                        const v1 = this.vertices4D[i];
                        const v2 = this.vertices4D[j];
                        
                        let diff = 0;
                        if (v1.x !== v2.x) diff++;
                        if (v1.y !== v2.y) diff++;
                        if (v1.z !== v2.z) diff++;
                        if (v1.w !== v2.w) diff++;
                        
                        if (diff === 1) {
                            this.edges.push([i, j]);
                        }
                    }
                }
            }
            
            createStones() {
                this.stones = [];
                
                // Generate random stone positions in 4D space
                const stoneCount = 120;
                const boardSize = 19;
                
                for (let i = 0; i < stoneCount; i++) {
                    const x = Math.floor(Math.random() * boardSize) - Math.floor(boardSize / 2);
                    const y = Math.floor(Math.random() * boardSize) - Math.floor(boardSize / 2);
                    const z = Math.floor(Math.random() * boardSize) - Math.floor(boardSize / 2);
                    const w = Math.floor(Math.random() * boardSize) - Math.floor(boardSize / 2);
                    
                    const position4D = new Vector4(
                        x * 0.15, y * 0.15, z * 0.15, w * 0.15
                    );
                    
                    const isBlack = Math.random() > 0.5;
                    this.stones.push({ position4D, isBlack });
                }
            }
            
            projectTo3D(v4) {
                // Perspective projection from 4D to 3D
                const w_offset = 4; // Viewer distance in 4th dimension
                const scale = w_offset / (w_offset - v4.w);
                return new Vector3(v4.x * scale, v4.y * scale, v4.z * scale);
            }
            
            projectTo2D(v3) {
                // Perspective projection from 3D to 2D
                const z_offset = 6; // Viewer distance
                const scale = z_offset / (z_offset - v3.z);
                return {
                    x: this.centerX + v3.x * this.scale * scale,
                    y: this.centerY + v3.y * this.scale * scale,
                    scale: scale
                };
            }
            
            drawLine(p1, p2, color, opacity) {
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            drawStone(pos, isBlack, scale, opacity) {
                const radius = 8 * scale;
                
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                
                // Draw glow
                const glowRadius = radius * 1.8;
                const gradient = this.ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowRadius);
                gradient.addColorStop(0, isBlack ? 'rgba(100, 100, 255, 0.3)' : 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw stone body
                const stoneGradient = this.ctx.createRadialGradient(
            pos.x - radius * 0.3, pos.y - radius * 0.3, 0,
            pos.x, pos.y, radius
        );
        
        if (isBlack) {
            stoneGradient.addColorStop(0, '#444444');
            stoneGradient.addColorStop(1, '#111111');
        } else {
            stoneGradient.addColorStop(0, '#ffffff');
            stoneGradient.addColorStop(1, '#cccccc');
        }
        
        this.ctx.fillStyle = stoneGradient;
        this.ctx.beginPath();
        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Draw highlight
        this.ctx.fillStyle = isBlack ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.5)';
        this.ctx.beginPath();
        this.ctx.arc(pos.x - radius * 0.3, pos.y - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.restore();
    }
    
    render(rotationMatrix, scrollProgress) {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Transform and project vertices
        const projectedVertices = this.vertices4D.map(v => {
            const transformed = rotationMatrix.transform(v);
            const projected3D = this.projectTo3D(transformed);
            return { 
                pos2D: this.projectTo2D(projected3D), 
                depth: projected3D.z,
                transformed4D: transformed
            };
        });
        
        // Sort by depth for proper rendering order
        const sortedVertices = projectedVertices.slice().sort((a, b) => a.depth - b.depth);
        
        // Draw tesseract edges
        this.edges.forEach(edge => {
            const v1 = projectedVertices[edge[0]];
            const v2 = projectedVertices[edge[1]];
            
            const avgDepth = (v1.depth + v2.depth) / 2;
            const opacity = Math.max(0.1, 0.7 - Math.abs(avgDepth) * 0.1);
            
            // Color based on 4D coordinates
            const color = `hsl(${(v1.transformed4D.w + v2.transformed4D.w) * 60 + 240}, 70%, 60%)`;
            
            this.drawLine(v1.pos2D, v2.pos2D, color, opacity);
        });
        
        // Draw stones with enhanced scroll-based animation
        this.stones.forEach((stone, index) => {
            const transformed = rotationMatrix.transform(stone.position4D);
            const projected3D = this.projectTo3D(transformed);
            const projected2D = this.projectTo2D(projected3D);
            
            // Enhanced scroll-based animation with multiple wave patterns
            const phase1 = scrollProgress * Math.PI * 6 + index * 0.15;
            const phase2 = scrollProgress * Math.PI * 3.2 + index * 0.08;
            const phase3 = this.time * 0.5 + index * 0.2; // Time-based ambient movement
            
            // Combine multiple movement patterns
            const scrollMovementY = Math.sin(phase1) * 20 * projected2D.scale;
            const scrollMovementX = Math.cos(phase2) * 12 * projected2D.scale;
            const ambientFloat = Math.sin(phase3) * 5 * projected2D.scale;
            
            // Apply velocity-based displacement
            const velocityDisplacement = this.scrollVelocity * index * 0.5;
            
            projected2D.y += scrollMovementY + ambientFloat + velocityDisplacement;
            projected2D.x += scrollMovementX + velocityDisplacement * 0.3;
            
            // Enhanced opacity and scale calculation
            const depthFactor = Math.abs(projected3D.z) * 0.15 + Math.abs(transformed.w) * 0.2;
            const baseOpacity = 0.9 - depthFactor;
            const scrollInfluence = Math.abs(Math.sin(phase1)) * 0.2;
            const opacity = Math.max(0.1, baseOpacity + scrollInfluence);
            
            const baseScale = projected2D.scale * (1 - Math.abs(transformed.w) * 0.1);
            const scaleVariation = 1 + Math.sin(phase2) * 0.3;
            const scale = Math.max(0.3, baseScale * scaleVariation);
            
            if (opacity > 0.05) {
                this.drawStone(projected2D, stone.isBlack, scale, opacity);
            }
        });
    }
    
    setupEventListeners() {
        window.addEventListener('resize', () => {
            this.resizeCanvas();
        });
        
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                this.updateVisualization();
            }, 8); // More responsive scroll handling
        }, { passive: true });
    }
    
    updateVisualization() {
        const currentScroll = window.pageYOffset;
        const maxScroll = Math.max(document.body.scrollHeight - window.innerHeight, 1);
        const scrollProgress = currentScroll / maxScroll;
        
        // Calculate scroll velocity for dynamic effects
        this.scrollVelocity = (currentScroll - this.lastScrollPosition) * 0.01;
        this.lastScrollPosition = currentScroll;
        
        // Create complex 4D rotation based on scroll with enhanced responsiveness
        const baseIntensity = 1 + Math.abs(this.scrollVelocity) * 0.5;
        const velocityInfluence = this.scrollVelocity * 0.1;
        
        this.currentRotation = new Matrix4D()
            .rotateXY((scrollProgress * Math.PI * 2.5 + velocityInfluence) * baseIntensity)
            .rotateXZ((scrollProgress * Math.PI * 1.8 - velocityInfluence * 0.5) * baseIntensity)
            .rotateXW((scrollProgress * Math.PI * 1.4 + velocityInfluence * 0.3) * baseIntensity)
            .rotateYZ((scrollProgress * Math.PI * 1.1 - velocityInfluence * 0.7) * baseIntensity)
            .rotateYW((scrollProgress * Math.PI * 0.9 + velocityInfluence * 0.4) * baseIntensity)
            .rotateZW((scrollProgress * Math.PI * 0.6 - velocityInfluence * 0.2) * baseIntensity);
        
        this.currentScrollProgress = scrollProgress;
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        this.time += 0.016; // Approximate 60fps
        
        // Update ambient rotation angles (reduced speed)
        this.ambientRotation.xy += Math.sin(this.time * 0.15) * 0.003 + 0.0015;
        this.ambientRotation.xz += Math.cos(this.time * 0.1) * 0.002 + 0.001;
        this.ambientRotation.xw += Math.sin(this.time * 0.08) * 0.002 + 0.0008;
        this.ambientRotation.yz += Math.cos(this.time * 0.12) * 0.0025 + 0.0012;
        this.ambientRotation.yw += Math.sin(this.time * 0.09) * 0.0015 + 0.0008;
        this.ambientRotation.zw += Math.cos(this.time * 0.06) * 0.001 + 0.0005;
        
        // Get current rotation or create default
        let rotation = this.currentRotation || new Matrix4D();
        
        // Apply ambient rotation that varies with scroll velocity
        const ambientIntensity = 1 + Math.abs(this.scrollVelocity) * 0.3;
        rotation = rotation
            .rotateXY(this.ambientRotation.xy * ambientIntensity)
            .rotateXZ(this.ambientRotation.xz * ambientIntensity)
            .rotateXW(this.ambientRotation.xw * ambientIntensity)
            .rotateYZ(this.ambientRotation.yz * ambientIntensity)
            .rotateYW(this.ambientRotation.yw * ambientIntensity)
            .rotateZW(this.ambientRotation.zw * ambientIntensity);
        
        const scrollProgress = this.currentScrollProgress || 0;
        
        // Decay scroll velocity
        this.scrollVelocity *= 0.95;
        
        this.render(rotation, scrollProgress);
    }
}

// Initialize when page loads
window.addEventListener('load', () => {
    new FourDGo();
});
    </script>
</body>
</html>